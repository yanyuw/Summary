# 浏览器的工作原理

参考：

+ [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

这篇文章主要以开源浏览器（Firefox、Chrome、Safari）为例。

## 浏览器是什么？

### **主要功能**

向服务器发出请求，在浏览器窗口中展示您选择的网络资源，即HTML 或者是PDF、图片等。资源的位置由URI（统一资源标示符）指定。

+ [URI](https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6)：**统一资源标识符**
+ URL ：**统一资源定位符**。

![wiki-URI](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/URI_Euler_Diagram_no_lone_URIs.svg/1024px-URI_Euler_Diagram_no_lone_URIs.svg.png)
URI可被视为定位符（URL），名称（URN）或两者兼备。统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN定义某事物的身份，而URL提供查找该事物的方法。

简单来说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。URI能在某一规则下能把一个资源独一无二地标识出来。

<!-- 回到正题，不同的浏览器的用户界面有很多彼此相同的元素，比如：

+ 前进后退按钮
+ 刷新/停止加载
+ 主页
+ 地址栏
+ 书签设置
 -->

### **高层结构**：

浏览器的主要组件有：

+ **用户界面**：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
+ **浏览器引擎**：在用户界面和呈现引擎之间传送指令。
+ **呈现引擎**：负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。（Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程）
+ **网络**：用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
+ **用户界面后端**：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
+ **JavaScript 解释器**：用于解析和执行 JavaScript 代码。
+ **数据存储**：这是持久层（在系统逻辑层面上，专著于实现数据持久化的一个相对独立的领域，是把数据保存到可掉电式存储设备中）。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。

![主要组件](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/layers.png)

## 浏览器的呈现引擎

+ Firefox：Gecko，这是 Mozilla 公司“自制”的呈现引擎。
+ Safari & Chrome ： [WebKit](https://webkit.org/)，一种开放源代码呈现引擎。

呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。

![呈现引擎的基本流程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/flow.png)

1. 解析HTML文档，转化成 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。
2. 渲染树结构。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。
3. 处理渲染树的布局。也就是为每个节点分配一个应出现在屏幕上的确切坐标。
4. 绘制渲染树。呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。

在这个过程中，为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。

接下来再让我深入地了解一下每个步骤吧！

### 解析（parse）

解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。

![2+3-1](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image009.png)

解析的过程可以分成两个子过程：

+ **词法分析**:将输入内容分割成大量标记(即构成内容的单位,相当于字典中的单词。)的过程
+ **语法分析**:应用语言的语法规则的过程

![从源文档到解析树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image011.png)

词法分析器（或称标记生成器）负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。

解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。

如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。

例子：

> 词汇：我们用的语言可包含整数、加号和减号。
> 
> 语法：
> 1. 构成语言的语法单位是表达式、项和运算符。
> 2. 我们用的语言可以包含任意数量的表达式。
> 3. 表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。
> 4. 运算符是加号或减号。
> 5. 项是一个整数或一个表达式。
> 
> 让我们分析一下 2 + 3 - 1。
> 匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。

解析完后，解析树需要经过翻译来变成机器代码，有点类似于编译。

![编译流程](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image013.png)

解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。

**DOM**是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。

比如说：
```
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>
```

可以被解析成如下的DOM树
![dom](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png)

### 呈现树构建

在 DOM 树构建的同时，浏览器还会构建另一个树结构：**呈现树**。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。

**呈现树和 DOM 树的关系** : 呈现器是和 DOM 元素相对应的，但并非一一对应。*非可视化的 DOM 元素*不会插入呈现树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。

有一些 DOM 元素*对应多个可视化对象*。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。

例如，“select”元素有 3 个呈现器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。

![呈现树及其对应的 DOM 树](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image025.png)

构建呈现树时，需要通过计算每个元素的样式属性来计算每一个呈现对象的可视化属性。

样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。

但是样式计算存在着难点，因为它是一个超大的结构，可能带来内存问题；层叠规则也较为复杂；而且如何优化为每个元素查找匹配规则也是一个问题（比如说`div div div di{...}`）

[看看浏览器是如何处理这些问题的](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Sharing_style_data)

### 布局

呈现器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为**布局**或重排。

HTML 采用**基于流的布局模型**，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算。

布局是一个递归的过程。它从根呈现器（对应于 HTML 文档的 `<html>` 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的呈现器计算几何信息。

**dirty 位系统**：
为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个呈现器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。

有两种标记：“dirty”和“children are dirty”。

**全局布局和增量布局**:
全局布局是指触发了整个呈现树范围的布局(影响所有呈现器的全局样式更改，例如字体大小更改；屏幕大小调整。)。

布局可以采用增量方式，也就是只对 dirty 呈现器进行布局（这样可能存在需要进行额外布局的弊端）。

增量布局是**异步执行**的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对呈现树进行遍历，并对 dirty 呈现器进行布局。
请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。

而全局布局往往是**同步触发**的。

布局处理：

1. 父呈现器确定自己的宽度。
2. 父呈现器依次处理子呈现器，并且：
    1. 放置子呈现器（设置 x,y 坐标）。
    2. 如果有必要，调用子呈现器的布局（如果子呈现器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子呈现器的高度。
3. 父呈现器根据子呈现器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父呈现器的父呈现器使用。
4. 将其 dirty 位设置为 false。

### 绘制

在绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。

**全局绘制和增量绘制**：
和布局一样，绘制也分为全局（绘制整个呈现树）和增量两种。

**绘制顺序**：
绘制的顺序其实就是元素*进入堆栈样式上下文*的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：

1. 背景颜色
2. 背景图片
3. 边框
4. 子代
5. 轮廓

---
小结：
webkit主流程图
![webkit](https://user-gold-cdn.xitu.io/2017/2/25/36020a2c568b21a4f5820f8bf0d5af55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
文章内还有很多地方似懂非懂，还需要再研究一下